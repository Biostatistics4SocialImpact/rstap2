# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' NUTS for STAP model assuming independence across observations, but allowing for difference in difference estimation
#' @param y vector of continuous outcomes
#' @param Z matrix of confounders 
#' @param W matrix of group-level effect slope covariates should be num_subj x 600 
#' @param distances array of distances
#' @param u_crs  compressed row storage indices for distances
#' @param subj_matrix_ N X n sparse matrix that has a 1 in element ij if subject i has an outcome in y (i+j) 
#' @param subj_n  n x 1 matrix that has 1/n_i in element i1 for the ith subject
#' @param stap_par_code detailed code for estimation set-up - see details
#' @param adapt_delta tuning parameter for adaptation
#' @param iter_max  maximum number of iterations
#' @param max_treedepth  maximum number of branches to grow for NUTS
#' @param warmup number of iterations for which to tune sampler
#' @param seed seed to initialize random number generator
#' @param diagnostics -for development use only
#' @details 
#' stap_par_code first element 0/1 indicator intercept estimate
#' stap_par_code second element 0/p indicator for dimension of delta vector
#' stap_par_code third element 0/q indicator for dimension of beta vector
#' stap_par_code fourth element 0/k indicator for dimension of beta_bar vector
stap_diffndiff_stfit <- function(y, Z, distances, u_crs, times, u_tcrs, subj_array_, subj_n, stap_par_code, adapt_delta, iter_max, max_treedepth, warmup, seed, diagnostics) {
    .Call(`_rstap2_stap_diffndiff_stfit`, y, Z, distances, u_crs, times, u_tcrs, subj_array_, subj_n, stap_par_code, adapt_delta, iter_max, max_treedepth, warmup, seed, diagnostics)
}

test_grads <- function(y, Z, beta_bar, beta, distances, u_crs, times, u_tcrs, subj_array_, subj_n, par_grid, stap_par_code, seed) {
    .Call(`_rstap2_test_grads`, y, Z, beta_bar, beta, distances, u_crs, times, u_tcrs, subj_array_, subj_n, par_grid, stap_par_code, seed)
}

test_sparse_matrix <- function(b, WW) {
    .Call(`_rstap2_test_sparse_matrix`, b, WW)
}

#' NUTS estimation for STAP model with either subj int or subj int and slope
#' @param y vector of continuous outcomes
#' @param Z matrix of confounders 
#' @param W matrix of group-level effect slope covariates should be num_subj x 600 
#' @param distances array of distances
#' @param u_crs  compressed row storage indices for distances
#' @param subj_matrix_ N X n sparse matrix that has a 1 in element ij if subject i has an outcome in y (i+j) 
#' @param subj_n  n x 1 matrix that has 1/n_i in element i1 for the ith subject
#' @param stap_par_code detailed code for estimation set-up - see details
#' @param adapt_delta tuning parameter for adaptation
#' @param iter_max  maximum number of iterations
#' @param max_treedepth  maximum number of branches to grow for NUTS
#' @param warmup number of iterations for which to tune sampler
#' @param seed seed to initialize random number generator
#' @param diagnostics -for development use only
stapdnd_glmer <- function(y, Z, WW, distances, times, u_crs, subj_matrix_, subj_n, stap_par_code, adapt_delta, iter_max, max_treedepth, warmup, seed, diagnostics) {
    .Call(`_rstap2_stapdnd_glmer`, y, Z, WW, distances, times, u_crs, subj_matrix_, subj_n, stap_par_code, adapt_delta, iter_max, max_treedepth, warmup, seed, diagnostics)
}

test_grads_glmer <- function(y, Z, WW, true_b_int, true_b_slope, beta_bar, beta, distances, u_crs, times, u_tcrs, subj_array_, subj_n, par_grid, stap_par_code, seed) {
    .Call(`_rstap2_test_grads_glmer`, y, Z, WW, true_b_int, true_b_slope, beta_bar, beta, distances, u_crs, times, u_tcrs, subj_array_, subj_n, par_grid, stap_par_code, seed)
}

